\n===== src/ui/brainpicker.tsx =====\n
import React from "react";
import { View, Text, Pressable, StyleSheet } from "react-native";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";

export type BrainGame = {
  id: "gonogo";
  title: string;
  subtitle: string;
  minutes: number;
};

export default function BrainPicker({
  games,
  selectedId,
  onSelect,
}: {
  games: BrainGame[];
  selectedId: BrainGame["id"];
  onSelect: (id: BrainGame["id"]) => void;
}) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  return (
    <View style={{ gap: spacing.sm }}>
      {games.map((g) => {
        const active = g.id === selectedId;
        return (
          <Pressable
            key={g.id}
            onPress={() => onSelect(g.id)}
            style={[
              styles.card,
              active ? { borderColor: theme.primary } : null,
            ]}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.title}>{g.title}</Text>
              <Text style={styles.sub}>{g.subtitle}</Text>
            </View>
            <Text style={styles.mins}>{g.minutes}m</Text>
          </Pressable>
        );
      })}
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    card: {
      flexDirection: "row",
      alignItems: "center",
      backgroundColor: theme.card,
      borderRadius: 18,
      borderWidth: 1,
      borderColor: theme.border,
      padding: spacing.md,
      gap: spacing.md,
    },
    title: { color: theme.text, fontSize: 16, fontWeight: "800" },
    sub: { color: theme.mutedText, marginTop: 4, fontSize: 13, fontWeight: "600" },
    mins: { color: theme.mutedText, fontSize: 12, fontWeight: "800" },
  });
\n===== src/ui/progressbar.tsx =====\n
import React from "react";
import { View, StyleSheet } from "react-native";
import { useAppTheme } from "../theme/themeContext";

export default function ProgressBar({ value }: { value: number }) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  const clamped = Math.max(0, Math.min(1, value));

  return (
    <View style={styles.track}>
      <View style={[styles.fill, { width: `${clamped * 100}%` }]} />
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    track: {
      height: 10,
      borderRadius: 999,
      backgroundColor: theme.border,
      overflow: "hidden",
    },
    fill: {
      height: 10,
      borderRadius: 999,
      backgroundColor: theme.primary,
    },
  });
\n===== src/ui/primarybutton.tsx =====\n
import React from "react";
import { Pressable, Text, StyleSheet, ViewStyle } from "react-native";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";

export default function PrimaryButton({
  title,
  onPress,
  disabled,
  style,
}: {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  style?: ViewStyle;
}) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  return (
    <Pressable
      onPress={onPress}
      disabled={disabled}
      style={({ pressed }) => [
        styles.btn,
        pressed && !disabled ? { opacity: 0.9 } : null,
        disabled ? { opacity: 0.45 } : null,
        style,
      ]}
    >
      <Text style={styles.txt}>{title}</Text>
    </Pressable>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    btn: {
      backgroundColor: theme.primary,
      paddingVertical: spacing.md,
      paddingHorizontal: spacing.lg,
      borderRadius: 16,
      alignItems: "center",
      justifyContent: "center",
    },
    txt: { color: theme.text, fontSize: 16, fontWeight: "800" },
  });
\n===== src/app/app.tsx =====\n
import React from "react";
import { NavigationContainer, DefaultTheme } from "@react-navigation/native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { ThemeProvider, useAppTheme } from "../theme/themeContext";
import RootNavigator from "./navigation";

function ThemedNavigation() {
  const { theme } = useAppTheme();

  const navTheme = {
    ...DefaultTheme,
    colors: {
      ...DefaultTheme.colors,
      background: theme.background,
      card: theme.card,
      text: theme.text,
      border: theme.border,
      primary: theme.primary,
      notification: theme.accent,
    },
  };

  return (
    <NavigationContainer theme={navTheme}>
      <RootNavigator />
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <SafeAreaProvider>
      <ThemeProvider>
        <ThemedNavigation />
      </ThemeProvider>
    </SafeAreaProvider>
  );
}
\n===== src/app/navigation.tsx =====\n
import React from "react";
import { createNativeStackNavigator } from "@react-navigation/native-stack";

import StartScreen from "../screens/startscreen";
import HomeScreen from "../screens/homescreen";
import GameScreen from "../screens/gamescreen";
import FocusTimerScreen from "../screens/focustimerscreen";
import FunFactsScreen from "../screens/funfactscreen";
import ProfileScreen from "../screens/profilescreen";
import ResultsScreen from "../screens/resultsscreen";
import OnboardingScreen from "../screens/onboardingscreen";

export type RootStackParamList = {
  Start: undefined;
  Home: undefined;
  Games: undefined;
  FocusTimer: undefined;
  FunFacts: undefined;
  Profile: undefined;
  Results: { runId: string };
  Onboarding: undefined;
};

const Stack = createNativeStackNavigator<RootStackParamList>();

export default function RootNavigator() {
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      <Stack.Screen name="Start" component={StartScreen} />
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Games" component={GameScreen} />
      <Stack.Screen name="FocusTimer" component={FocusTimerScreen} />
      <Stack.Screen name="FunFacts" component={FunFactsScreen} />
      <Stack.Screen name="Profile" component={ProfileScreen} />
      <Stack.Screen name="Results" component={ResultsScreen} />
      <Stack.Screen name="Onboarding" component={OnboardingScreen} />
    </Stack.Navigator>
  );
}
\n===== src/game/gonogo/stimuli.ts =====\n
import { Difficulty, Stimulus } from "./types";

function uid() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

export function generateStimuli(totalTrials: number, diff: Difficulty): Stimulus[] {
  const arr: Stimulus[] = [];
  for (let i = 0; i < totalTrials; i++) {
    const r = Math.random();
    const kind = r < diff.noGoRate ? "NOGO" : "GO";
    arr.push({ id: uid(), kind });
  }
  // ensure at least a few GO trials
  if (arr.filter(s => s.kind === "GO").length < Math.max(3, Math.floor(totalTrials * 0.4))) {
    for (let i = 0; i < Math.min(3, totalTrials); i++) arr[i].kind = "GO";
  }
  return arr;
}
\n===== src/game/gonogo/engine.ts =====\n
import { EngineConfig, Stimulus } from "./types";
import { generateStimuli } from "./stimuli";
import { computeStats } from "./rules";

export function createRun(config: EngineConfig) {
  const stimuli: Stimulus[] = generateStimuli(config.totalTrials, config.difficulty);
  return stimuli;
}

export function finishRun(stimuli: Stimulus[]) {
  return computeStats(stimuli);
}
\n===== src/game/gonogo/types.ts =====\n
export type StimulusKind = "GO" | "NOGO";

export type Stimulus = {
  id: string;
  kind: StimulusKind;
  shownAt?: number;
  respondedAt?: number;
  correct?: boolean;
  reactionMs?: number | null;
};

export type Difficulty = {
  level: number; // 1..10
  stimulusMs: number; // how long stimulus is visible
  isiMs: number; // time between stimuli
  noGoRate: number; // 0..1
};

export type RunStats = {
  goCorrect: number;
  goWrong: number;
  noGoCorrect: number;
  noGoWrong: number;
  accuracy: number; // 0..1
  avgReactionMs: number | null;
  focusScore: number; // 0..100
};

export type EngineConfig = {
  totalTrials: number;
  difficulty: Difficulty;
};
\n===== src/game/gonogo/difficulty.ts =====\n
import { Difficulty, RunStats } from "./types";

export function difficultyForLevel(level: number): Difficulty {
  const lvl = Math.max(1, Math.min(10, level));
  // harder => shorter stimulus + shorter ISI + more NOGO
  const stimulusMs = 750 - (lvl - 1) * 45; // ~750 -> ~345
  const isiMs = 650 - (lvl - 1) * 35; // ~650 -> ~335
  const noGoRate = 0.18 + (lvl - 1) * 0.03; // ~0.18 -> ~0.45
  return {
    level: lvl,
    stimulusMs: Math.max(280, stimulusMs),
    isiMs: Math.max(250, isiMs),
    noGoRate: Math.min(0.5, noGoRate),
  };
}

export function adaptLevel(current: number, stats: RunStats): number {
  // simple adaptive rule: accuracy + reaction time
  const acc = stats.accuracy;
  const rt = stats.avgReactionMs ?? 9999;

  if (acc >= 0.88 && rt <= 420) return Math.min(10, current + 1);
  if (acc >= 0.80 && rt <= 520) return Math.min(10, current + 1);
  if (acc <= 0.62) return Math.max(1, current - 1);
  return current;
}
\n===== src/game/gonogo/rules.ts =====\n
import { RunStats, Stimulus } from "./types";

export function computeStats(stimuli: Stimulus[]): RunStats {
  let goCorrect = 0, goWrong = 0, noGoCorrect = 0, noGoWrong = 0;
  const rts: number[] = [];

  for (const s of stimuli) {
    if (s.kind === "GO") {
      if (s.correct) {
        goCorrect++;
        if (typeof s.reactionMs === "number") rts.push(s.reactionMs);
      } else {
        goWrong++;
      }
    } else {
      if (s.correct) noGoCorrect++;
      else noGoWrong++;
    }
  }

  const total = stimuli.length || 1;
  const correct = goCorrect + noGoCorrect;
  const accuracy = correct / total;

  const avgReactionMs = rts.length ? Math.round(rts.reduce((a, b) => a + b, 0) / rts.length) : null;

  // Focus score: weighted blend (simple + demo-friendly)
  // accuracy is king; fast RT helps; penalties for NOGO errors (impulsivity)
  const impulsivePenalty = Math.min(20, noGoWrong * 6);
  const rtScore =
    avgReactionMs === null ? 50 :
    avgReactionMs <= 350 ? 100 :
    avgReactionMs <= 450 ? 85 :
    avgReactionMs <= 600 ? 65 : 45;

  let focusScore = Math.round(accuracy * 70 + (rtScore * 0.30) - impulsivePenalty);
  focusScore = Math.max(0, Math.min(100, focusScore));

  return { goCorrect, goWrong, noGoCorrect, noGoWrong, accuracy, avgReactionMs, focusScore };
}
\n===== src/storage/local.ts =====\n
import AsyncStorage from "@react-native-async-storage/async-storage";

export async function getJSON<T>(key: string, fallback: T): Promise<T> {
  try {
    const raw = await AsyncStorage.getItem(key);
    if (!raw) return fallback;
    return JSON.parse(raw) as T;
  } catch {
    return fallback;
  }
}

export async function setJSON<T>(key: string, value: T): Promise<void> {
  await AsyncStorage.setItem(key, JSON.stringify(value));
}

export async function getString(key: string, fallback = ""): Promise<string> {
  const v = await AsyncStorage.getItem(key);
  return v ?? fallback;
}

export async function setString(key: string, value: string): Promise<void> {
  await AsyncStorage.setItem(key, value);
}

export async function removeKey(key: string): Promise<void> {
  await AsyncStorage.removeItem(key);
}

export const Keys = {
  onboarded: "thryv:onboarded",
  profile: "thryv:profile",
  lastRun: "thryv:lastRun",
  runs: "thryv:runs",
  freePlaysDaily: "thryv:freePlaysDaily",
} as const;

export type Profile = {
  createdAt: string;
  totalRuns: number;
  streakDays: number;
  lastActiveDate: string; // YYYY-MM-DD
  isPremium: boolean; // toggle for demo
};

export type GameRun = {
  id: string;
  game: "gonogo";
  startedAt: string;
  endedAt: string;
  accuracy: number; // 0..1
  avgReactionMs: number | null; // null if no-go only (rare)
  focusScore: number; // 0..100
  difficultyLevel: number; // 1..10
  goCorrect: number;
  goWrong: number;
  noGoCorrect: number;
  noGoWrong: number;
};

export function todayKey(): string {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}
\n===== src/screens/onboardingscreen.tsx =====\n
import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "../app/navigation";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";
import PrimaryButton from "../ui/primarybutton";
import { setString, Keys, getJSON, setJSON, Profile, todayKey } from "../storage/local";

type Props = NativeStackScreenProps<RootStackParamList, "Onboarding">;

export default function OnboardingScreen({ navigation }: Props) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  async function finish() {
    await setString(Keys.onboarded, "1");
    const existing = await getJSON<Profile | null>(Keys.profile, null);
    if (!existing) {
      await setJSON(Keys.profile, {
        createdAt: new Date().toISOString(),
        totalRuns: 0,
        streakDays: 0,
        lastActiveDate: todayKey(),
        isPremium: false,
      });
    }
    navigation.replace("Home");
  }

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>How it works</Text>

      <View style={styles.card}>
        <Text style={styles.b}>1) Prime</Text>
        <Text style={styles.p}>Play a 2–3 minute brain sprint.</Text>

        <View style={{ height: spacing.md }} />

        <Text style={styles.b}>2) Study</Text>
        <Text style={styles.p}>Use the focus timer (25 / 50 min).</Text>

        <View style={{ height: spacing.md }} />

        <Text style={styles.b}>3) Reset</Text>
        <Text style={styles.p}>Avoid doom-scrolling between blocks.</Text>
      </View>

      <View style={{ height: spacing.lg }} />
      <PrimaryButton title="Continue" onPress={finish} />
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: {
      flex: 1,
      backgroundColor: theme.background,
      padding: spacing.xl,
      justifyContent: "center",
    },
    h: { color: theme.text, fontSize: 26, fontWeight: "900", marginBottom: spacing.md },
    card: {
      backgroundColor: theme.card,
      borderRadius: 20,
      borderWidth: 1,
      borderColor: theme.border,
      padding: spacing.lg,
    },
    b: { color: theme.text, fontSize: 16, fontWeight: "900" },
    p: {
      color: theme.mutedText,
      marginTop: 6,
      fontSize: 14,
      fontWeight: "600",
      lineHeight: 20,
    },
  });
\n===== src/screens/profilescreen.tsx =====\n
import React, { useEffect, useState } from "react";
import { View, Text, StyleSheet, Switch } from "react-native";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";
import { getJSON, setJSON, Keys, Profile, GameRun } from "../storage/local";

export default function ProfileScreen() {
  const { theme, toggleTheme, mode } = useAppTheme();
  const styles = makeStyles(theme);

  const [profile, setProfile] = useState<Profile | null>(null);
  const [runs, setRuns] = useState<GameRun[]>([]);

  useEffect(() => {
    (async () => {
      setProfile(await getJSON(Keys.profile, null));
      setRuns(await getJSON(Keys.runs, []));
    })();
  }, []);

  async function togglePremium(v: boolean) {
    if (!profile) return;
    const next = { ...profile, isPremium: v };
    setProfile(next);
    await setJSON(Keys.profile, next);
  }

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Profile</Text>

      <View style={{ height: spacing.lg }} />

      <View style={styles.card}>
        <Text style={styles.label}>Streak</Text>
        <Text style={styles.big}>{profile?.streakDays ?? 0} days</Text>

        <View style={{ height: spacing.md }} />

        <Text style={styles.label}>Total runs</Text>
        <Text style={styles.big}>{profile?.totalRuns ?? 0}</Text>

        <View style={{ height: spacing.md }} />

        <View style={styles.row}>
          <Text style={styles.label}>Premium (demo)</Text>
          <Switch
            value={!!profile?.isPremium}
            onValueChange={togglePremium}
          />
        </View>

        <View style={{ height: spacing.md }} />

        <View style={styles.row}>
          <Text style={styles.label}>Dark Mode</Text>
          <Switch
            value={mode === "dark"}
            onValueChange={toggleTheme}
          />
        </View>
      </View>

      <View style={{ height: spacing.lg }} />

      <View style={styles.card}>
        <Text style={styles.label}>Recent scores</Text>
        {runs.slice(0, 5).map((r) => (
          <Text key={r.id} style={styles.small}>
            • {r.focusScore}/100 — {Math.round(r.accuracy * 100)}% — L{r.difficultyLevel}
          </Text>
        ))}
      </View>
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: {
      flex: 1,
      backgroundColor: theme.background,
      padding: spacing.xl,
    },
    h: { color: theme.text, fontSize: 28, fontWeight: "900" },
    card: {
      backgroundColor: theme.card,
      borderRadius: 20,
      borderWidth: 1,
      borderColor: theme.border,
      padding: spacing.lg,
    },
    label: { color: theme.mutedText, fontWeight: "800" },
    big: { color: theme.text, fontSize: 32, fontWeight: "900" },
    small: { color: theme.mutedText, marginTop: 6, fontWeight: "700" },
    row: {
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
    },
  });
\n===== src/screens/funfactscreen.tsx =====\n
import React, { useMemo, useState } from "react";
import { View, Text, StyleSheet } from "react-native";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";
import PrimaryButton from "../ui/primarybutton";

const facts = [
  "Attention is a limited resource — doom-scrolling makes refocusing harder.",
  "Reaction time slows when you're mentally fatigued.",
  "Working memory is the brain’s scratchpad for learning.",
  "Impulse control is critical for sustained focus.",
];

export default function FunFactScreen() {
  const { theme } = useAppTheme();
  const [seed, setSeed] = useState(0);

  const fact = useMemo(() => facts[seed % facts.length], [seed]);
  const styles = makeStyles(theme);

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Fun facts</Text>

      <View style={styles.card}>
        <Text style={styles.p}>{fact}</Text>
      </View>

      <View style={{ height: spacing.lg }} />
      <PrimaryButton title="New fact" onPress={() => setSeed((s) => s + 1)} />
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: {
      flex: 1,
      backgroundColor: theme.background,
      padding: spacing.xl,
      justifyContent: "center",
    },
    h: { color: theme.text, fontSize: 26, fontWeight: "900" },
    card: {
      backgroundColor: theme.card,
      borderRadius: 20,
      borderWidth: 1,
      borderColor: theme.border,
      padding: spacing.lg,
      marginTop: spacing.md,
    },
    p: { color: theme.text, fontSize: 16, fontWeight: "700", lineHeight: 24 },
  });
\n===== src/screens/gonogo_screen.tsx =====\n
import React, { useEffect, useMemo, useRef, useState } from "react";
import { View, Text, StyleSheet, Pressable } from "react-native";
import { useAppTheme } from "../theme/themeContext";
import { spacing } from "../theme/spacing";
import ProgressBar from "../ui/progressbar";
import PrimaryButton from "../ui/primarybutton";
import { createRun, finishRun } from "../game/gonogo/engine";
import { difficultyForLevel, adaptLevel } from "../game/gonogo/difficulty";
import { Stimulus, RunStats } from "../game/gonogo/types";
import { getJSON, setJSON, Keys, GameRun, Profile, todayKey } from "../storage/local";

function uid() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

export default function GoNoGoGame({
  onExit,
  onFinished,
}: {
  onExit: () => void;
  onFinished: () => void;
}) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  const totalTrials = 20;
  const [level, setLevel] = useState(3);
  const diff = useMemo(() => difficultyForLevel(level), [level]);

  const [stimuli, setStimuli] = useState<Stimulus[]>(() =>
    createRun({ totalTrials, difficulty: diff })
  );
  const [index, setIndex] = useState(0);
  const [phase, setPhase] = useState<"READY" | "SHOW" | "ISI" | "DONE">("READY");
  const [nowStimulus, setNowStimulus] = useState<Stimulus | null>(null);

  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const startedAtRef = useRef(new Date().toISOString());

  function clearTimer() {
    if (timerRef.current) clearTimeout(timerRef.current);
    timerRef.current = null;
  }

  useEffect(() => {
    if (phase === "READY") {
      setStimuli(createRun({ totalTrials, difficulty: diff }));
      setIndex(0);
      setNowStimulus(null);
    }
  }, [diff.level]);

  useEffect(() => {
    clearTimer();
    if (phase === "SHOW") {
      timerRef.current = setTimeout(() => {
        setStimuli((prev) => {
          const copy = [...prev];
          const s = copy[index];
          if (s && s.respondedAt == null) {
            copy[index] = { ...s, correct: s.kind === "NOGO", reactionMs: null };
          }
          return copy;
        });
        setPhase("ISI");
      }, diff.stimulusMs);
    } else if (phase === "ISI") {
      timerRef.current = setTimeout(() => {
        const next = index + 1;
        next >= stimuli.length ? setPhase("DONE") : (setIndex(next), setPhase("SHOW"));
      }, diff.isiMs);
    }
    return clearTimer;
  }, [phase, index]);

  useEffect(() => {
    if (phase === "SHOW") {
      const s = stimuli[index];
      setNowStimulus(s ? { ...s, shownAt: Date.now() } : null);
    } else {
      setNowStimulus(null);
    }
  }, [phase, index]);

  function tap() {
    if (phase !== "SHOW") return;
    setStimuli((prev) => {
      const copy = [...prev];
      const s = copy[index];
      if (!s) return prev;
      copy[index] = {
        ...s,
        respondedAt: Date.now(),
        reactionMs: Date.now() - (s.shownAt ?? Date.now()),
        correct: s.kind === "GO",
      };
      return copy;
    });
    setPhase("ISI");
  }

  useEffect(() => {
    if (phase === "DONE") {
      const stats = finishRun(stimuli);
      persistAndFinish(stats).catch(onFinished);
    }
  }, [phase]);

  async function persistAndFinish(stats: RunStats) {
    const run: GameRun = {
      id: uid(),
      game: "gonogo",
      startedAt: startedAtRef.current,
      endedAt: new Date().toISOString(),
      accuracy: stats.accuracy,
      avgReactionMs: stats.avgReactionMs,
      focusScore: stats.focusScore,
      difficultyLevel: level,
      goCorrect: stats.goCorrect,
      goWrong: stats.goWrong,
      noGoCorrect: stats.noGoCorrect,
      noGoWrong: stats.noGoWrong,
    };

    const runs = await getJSON<GameRun[]>(Keys.runs, []);
    await setJSON(Keys.runs, [run, ...runs].slice(0, 50));
    await setJSON(Keys.lastRun, run);

    const profile = await getJSON<Profile>(Keys.profile, {
      createdAt: new Date().toISOString(),
      totalRuns: 0,
      streakDays: 0,
      lastActiveDate: todayKey(),
      isPremium: false,
    });

    await setJSON(Keys.profile, {
      ...profile,
      totalRuns: profile.totalRuns + 1,
      lastActiveDate: todayKey(),
    });

    await setJSON("thryv:gonogo:level", adaptLevel(level, stats));
    onFinished();
  }

  const progress = index / totalTrials;
  const kind = nowStimulus?.kind;
  const isGo = kind === "GO";

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Go / No-Go</Text>
      <ProgressBar value={progress} />

      <View style={{ flex: 1 }} />

      {phase === "READY" ? (
        <>
          <PrimaryButton title="Start" onPress={() => setPhase("SHOW")} />
          <PrimaryButton title="Exit" onPress={onExit} style={{ backgroundColor: theme.card }} />
        </>
      ) : (
        <Pressable onPress={tap} style={styles.pad}>
          <View
            style={[
              styles.stimulus,
              kind === "GO" && { backgroundColor: "#34D399" },
              kind === "NOGO" && { backgroundColor: "#FB7185" },

            ]}
          >
            <Text style={styles.stxt}>{kind ? (isGo ? "GO" : "NO") : ""}</Text>
          </View>
          <Text style={styles.hint}>{kind ? (isGo ? "TAP" : "DON’T TAP") : ""}</Text>
        </Pressable>
      )}
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: { flex: 1, backgroundColor: theme.background, padding: spacing.xl },
    h: { color: theme.text, fontSize: 28, fontWeight: "900" },
    pad: { alignItems: "center", gap: spacing.md },
    stimulus: {
      width: 220,
      height: 220,
      borderRadius: 36,
      alignItems: "center",
      justifyContent: "center",
      borderWidth: 1,
      borderColor: theme.border,
    },
    stxt: { color: theme.text, fontSize: 44, fontWeight: "900" },
    hint: { color: theme.mutedText, fontWeight: "900" },
  });
\n===== src/screens/gamescreen.tsx =====\n
import React, { useEffect, useMemo, useState } from "react";
import { View, Text, StyleSheet, Alert } from "react-native";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "../app/navigation";
import { useAppTheme } from "../theme/themeContext";
import { spacing } from "../theme/spacing";
import PrimaryButton from "../ui/primarybutton";
import BrainPicker, { BrainGame } from "../ui/brainpicker";
import { getJSON, setJSON, Keys, Profile, todayKey } from "../storage/local";
import GoNoGoGame from "./gonogo_screen";

type Props = NativeStackScreenProps<RootStackParamList, "Games">;

type DailyPlays = { date: string; used: number };

const FREE_PLAYS_PER_DAY = 3;

export default function GameScreen({ navigation }: Props) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  const games: BrainGame[] = useMemo(
    () => [
      {
        id: "gonogo",
        title: "Go / No-Go",
        subtitle: "Impulse control + sustained attention",
        minutes: 2,
      },
    ],
    []
  );

  const [selected, setSelected] = useState<BrainGame["id"]>("gonogo");
  const [profile, setProfile] = useState<Profile | null>(null);
  const [daily, setDaily] = useState<DailyPlays>({
    date: todayKey(),
    used: 0,
  });
  const [playing, setPlaying] = useState(false);

  useEffect(() => {
    (async () => {
      setProfile(await getJSON(Keys.profile, null));
      const d = await getJSON<DailyPlays>(Keys.freePlaysDaily, {
        date: todayKey(),
        used: 0,
      });
      if (d.date !== todayKey()) {
        const reset = { date: todayKey(), used: 0 };
        await setJSON(Keys.freePlaysDaily, reset);
        setDaily(reset);
      } else {
        setDaily(d);
      }
    })();
  }, []);

  function canPlay(): boolean {
    if (profile?.isPremium) return true;
    return daily.used < FREE_PLAYS_PER_DAY;
  }

  async function consumePlay() {
    if (profile?.isPremium) return;
    const next = { date: todayKey(), used: daily.used + 1 };
    setDaily(next);
    await setJSON(Keys.freePlaysDaily, next);
  }

  function start() {
    if (!canPlay()) {
      Alert.alert(
        "Daily limit reached",
        `Free users get ${FREE_PLAYS_PER_DAY} plays/day.`
      );
      return;
    }
    setPlaying(true);
  }

  if (playing) {
    return (
      <GoNoGoGame
        onExit={() => setPlaying(false)}
        onFinished={() => {
          consumePlay().catch(() => {});
          navigation.replace("Home");
        }}
      />
    );
  }

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Brain sprints</Text>
      <Text style={styles.sub}>
        2–3 minutes. Fast reset. Real focus.
      </Text>

      <View style={{ height: spacing.lg }} />

      <BrainPicker
        games={games}
        selectedId={selected}
        onSelect={setSelected}
      />

      <View style={{ height: spacing.lg }} />

      <PrimaryButton title="Start" onPress={start} />

      <View style={{ height: spacing.sm }} />

      <PrimaryButton
        title="Back"
        onPress={() => navigation.goBack()}
        style={{ backgroundColor: theme.card }}
      />

      <View style={{ flex: 1 }} />

      <Text style={styles.footer}>
        {profile?.isPremium
          ? "Premium unlimited"
          : `Free plays left today: ${Math.max(
              0,
              FREE_PLAYS_PER_DAY - daily.used
            )}`}
      </Text>
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: {
      flex: 1,
      backgroundColor: theme.background,
      padding: spacing.xl,
    },
    h: {
      color: theme.text,
      fontSize: 28,
      fontWeight: "900",
    },
    sub: {
      color: theme.muted,
      marginTop: 6,
      fontWeight: "600",
    },
    footer: {
      color: theme.muted,
      fontSize: 12,
      fontWeight: "700",
      opacity: 0.8,
    },
  });
\n===== src/screens/startscreen.tsx =====\n
import React from "react";
import { View, Text, StyleSheet } from "react-native";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "../app/navigation";
import { useAppTheme } from "../theme/themeContext";
import { spacing } from "../theme/spacing";
import PrimaryButton from "../ui/primarybutton";

type Props = NativeStackScreenProps<RootStackParamList, "Start">;

export default function StartScreen({ navigation }: Props) {
  const { theme } = useAppTheme();

  return (
    <View style={[styles.wrap, { backgroundColor: theme.background }]}>
      <Text style={[styles.h, { color: theme.text }]}>Welcome</Text>
      <Text style={[styles.sub, { color: theme.muted }]}>
        Train your focus. One sprint at a time.
      </Text>

      <View style={{ height: spacing.xl }} />

      {/* ✅ PLAY = GO TO GAMES */}
      <PrimaryButton
        title="Play"
        onPress={() => navigation.navigate("Games")}
      />

      <View style={{ height: spacing.sm }} />

      {/* ✅ FOCUS TIMER = GO TO TIMER */}
      <PrimaryButton
        title="Focus Timer"
        onPress={() => navigation.navigate("FocusTimer")}
        style={{ backgroundColor: theme.card }}
      />

      <View style={{ flex: 1 }} />

      <PrimaryButton
        title="Continue"
        onPress={() => navigation.replace("Home")}
        style={{ backgroundColor: theme.card }}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    flex: 1,
    padding: spacing.xl,
  },
  h: {
    fontSize: 32,
    fontWeight: "900",
  },
  sub: {
    marginTop: 8,
    fontWeight: "600",
  },
});
\n===== src/screens/focustimerscreen.tsx =====\n
import React, { useState, useEffect } from "react";
import { View, Text, StyleSheet } from "react-native";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";
import PrimaryButton from "../ui/primarybutton";

export default function FocusTimerScreen() {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  const [seconds, setSeconds] = useState(300);
  const [running, setRunning] = useState(false);

  useEffect(() => {
    if (!running) return;
    const interval = setInterval(() => {
      setSeconds((s) => (s > 0 ? s - 1 : 0));
    }, 1000);
    return () => clearInterval(interval);
  }, [running]);

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Focus Sprint</Text>
      <Text style={styles.timer}>{seconds}s</Text>

      <PrimaryButton
        title={running ? "Pause" : "Start"}
        onPress={() => setRunning((r) => !r)}
      />
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: {
      flex: 1,
      backgroundColor: theme.background,
      justifyContent: "center",
      alignItems: "center",
      padding: spacing.xl,
    },
    h: {
      color: theme.text,
      fontSize: 26,
      fontWeight: "900",
    },
    timer: {
      marginVertical: spacing.xl,
      fontSize: 54,
      fontWeight: "900",
      color: theme.text,
    },
  });
\n===== src/screens/resultsscreen.tsx =====\n
import React, { useEffect, useState } from "react";
import { View, Text, StyleSheet } from "react-native";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "../app/navigation";
import { spacing } from "../theme/spacing";
import { useAppTheme } from "../theme/themeContext";
import { getJSON, Keys, GameRun } from "../storage/local";

type Props = NativeStackScreenProps<RootStackParamList, "Results">;

export default function ResultsScreen({ route }: Props) {
  const { theme } = useAppTheme();
  const styles = makeStyles(theme);

  const [run, setRun] = useState<GameRun | null>(null);

  useEffect(() => {
    (async () => {
      const last = await getJSON<GameRun | null>(Keys.lastRun, null);
      setRun(last);
    })();
  }, []);

  if (!run) {
    return (
      <View style={styles.wrap}>
        <Text style={styles.h}>Loading results…</Text>
      </View>
    );
  }

  return (
    <View style={styles.wrap}>
      <Text style={styles.h}>Results</Text>
      <Text style={styles.t}>Focus Score: {run.focusScore}/100</Text>
      <Text style={styles.t}>Accuracy: {Math.round(run.accuracy * 100)}%</Text>
      <Text style={styles.t}>Difficulty: L{run.difficultyLevel}</Text>
    </View>
  );
}

const makeStyles = (theme: any) =>
  StyleSheet.create({
    wrap: { flex: 1, backgroundColor: theme.background, padding: spacing.xl },
    h: { color: theme.text, fontSize: 28, fontWeight: "900", marginBottom: spacing.md },
    t: { color: theme.mutedText, fontSize: 16, marginBottom: 8 },
  });
\n===== src/screens/homescreen.tsx =====\n
import React, { useEffect, useState } from "react";
import { View, Text, StyleSheet } from "react-native";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { RootStackParamList } from "../app/navigation";
import { useAppTheme } from "../theme/themeContext";
import { spacing } from "../theme/spacing";
import PrimaryButton from "../ui/primarybutton";
import { getJSON, Keys, Profile, GameRun } from "../storage/local";

type Props = NativeStackScreenProps<RootStackParamList, "Home">;

export default function HomeScreen({ navigation }: Props) {
  const { theme } = useAppTheme();
  const [profile, setProfile] = useState<Profile | null>(null);
  const [lastRun, setLastRun] = useState<GameRun | null>(null);

  useEffect(() => {
    (async () => {
      setProfile(await getJSON(Keys.profile, null));
      setLastRun(await getJSON(Keys.lastRun, null));
    })();
  }, []);

  return (
    <View style={[styles.wrap, { backgroundColor: theme.background }]}>
      <Text style={[styles.title, { color: theme.text }]}>Welcome back</Text>
      <Text style={[styles.sub, { color: theme.muted }]}>
        Prime your brain. Then crush the study block.
      </Text>

      <View style={{ height: spacing.lg }} />

      {/* ✅ THIS GOES TO GAME SCREEN */}
      <PrimaryButton
        title="Play"
        onPress={() => navigation.navigate("Games")}
      />

      <View style={{ height: spacing.sm }} />

      {/* ✅ THIS GOES TO TIMER */}
      <PrimaryButton
        title="Focus Timer"
        onPress={() => navigation.navigate("FocusTimer")}
        style={{ backgroundColor: theme.card }}
      />

      <View style={{ height: spacing.sm }} />

      <PrimaryButton
        title="Profile"
        onPress={() => navigation.navigate("Profile")}
        style={{ backgroundColor: theme.card }}
      />

      <View style={{ height: spacing.sm }} />

      <PrimaryButton
        title="Fun Facts"
        onPress={() => navigation.navigate("FunFacts")}
        style={{ backgroundColor: theme.card }}
      />

      <View style={{ flex: 1 }} />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    flex: 1,
    padding: spacing.xl,
  },
  title: {
    fontSize: 28,
    fontWeight: "900",
  },
  sub: {
    marginTop: 6,
    fontWeight: "600",
  },
});
\n===== src/theme/colors.ts =====\n
export type AppTheme = {
  background: string;
  card: string;
  text: string;
  muted: string;
  primary: string;
  success: string;
  danger: string;
  border: string;
  accent: string;
};

export const lightTheme: AppTheme = {
  background: "#FFFFFF",
  card: "#F5F7FF",
  text: "#111111",
  muted: "#6B7280",
  primary: "#6C7CFF",
  success: "#34D399",
  danger: "#FB7185",
  border: "rgba(0,0,0,0.1)",
  accent: "#6C7CFF",
};

export const darkTheme: AppTheme = {
  background: "#0B1020",
  card: "#111A33",
  text: "#EAF0FF",
  muted: "#A9B4D0",
  primary: "#6C7CFF",
  success: "#34D399",
  danger: "#FB7185",
  border: "rgba(255,255,255,0.10)",
  accent: "#6C7CFF",
};
\n===== src/theme/text.ts =====\n
export const text = {
  h1: { fontSize: 28, fontWeight: "800" as const },
  h2: { fontSize: 20, fontWeight: "700" as const },
  body: { fontSize: 16, fontWeight: "500" as const },
  small: { fontSize: 13, fontWeight: "500" as const },
};
\n===== src/theme/themeContext.tsx =====\n
import React, { createContext, useContext, useState } from "react";
import { lightTheme, darkTheme, AppTheme } from "./colors";

type ThemeMode = "light" | "dark";

type ThemeContextType = {
  theme: AppTheme;
  mode: ThemeMode;
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [mode, setMode] = useState<ThemeMode>("light");

  const toggleTheme = () => {
    setMode((prev) => (prev === "light" ? "dark" : "light"));
  };

  const theme = mode === "light" ? lightTheme : darkTheme;

  return (
    <ThemeContext.Provider value={{ theme, mode, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useAppTheme() {
  const ctx = useContext(ThemeContext);
  if (!ctx) {
    throw new Error("useAppTheme must be used inside ThemeProvider");
  }
  return ctx;
}
\n===== src/theme/spacing.ts =====\n
export const spacing = {
  xs: 6,
  sm: 10,
  md: 16,
  lg: 22,
  xl: 28,
  xxl: 36,
};
